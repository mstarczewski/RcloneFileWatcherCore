name: Build & Release

on:
  push:
    tags:
      - 'v*.*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Optional tag name'
        required: false
        default: ''

# give the workflow permission to create/update releases and upload assets
permissions:
  contents: write

jobs:
  build-windows:
    runs-on: windows-latest
    env:
      Configuration: Release
    outputs:
      version: ${{ steps.extract_version.outputs.version }}

    steps:
      - name: "Checkout repo with full history"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "Setup .NET"
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: "Restore"
        run: dotnet restore

      - name: "Build solution"
        run: dotnet build --no-restore -c ${{ env.Configuration }}

      - name: "Run tests"
        run: dotnet test RcloneFileWatcherCore.Tests/RcloneFileWatcherCore.Tests.csproj --no-build -c ${{ env.Configuration }}

      - name: "Publish Windows app"
        run: dotnet publish RcloneFileWatcherCore/RcloneFileWatcherCore.csproj -c Release -r win-x64 --self-contained false /p:PublishSingleFile=true

      - name: "Prepare Windows artifacts"
        run: |
          New-Item -ItemType Directory -Path "${{ github.workspace }}\artifacts\win-x64" -Force
          Copy-Item "${{ github.workspace }}\RcloneFileWatcherCore\bin\Release\net8.0\win-x64\publish\*.exe" "${{ github.workspace }}\artifacts\win-x64\" -Force
          if (Test-Path "${{ github.workspace }}\RcloneFileWatcherCore\bin\Release\net8.0\win-x64\publish\version.json") {
            Copy-Item "${{ github.workspace }}\RcloneFileWatcherCore\bin\Release\net8.0\win-x64\publish\version.json" "${{ github.workspace }}\artifacts\win-x64\" -Force
          }
          Compress-Archive -Path "${{ github.workspace }}\artifacts\win-x64\*" -DestinationPath "${{ github.workspace }}\artifacts\app-win-x64.zip" -Force

      - name: "Extract version from Windows assembly"
        id: extract_version
        shell: powershell
        run: |
          $assemblyPath = "${{ github.workspace }}\RcloneFileWatcherCore\bin\Release\net8.0\win-x64\publish\RcloneFileWatcherCore.exe"
          if (-Not (Test-Path $assemblyPath)) {
            Write-Error "Assembly not found at $assemblyPath"
            exit 1
          }
          $version = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($assemblyPath).ProductVersion
          Write-Host "Extracted version: $version"
          echo "version=$version" >> $env:GITHUB_OUTPUT

      - name: "Upload Windows artifacts"
        uses: actions/upload-artifact@v4
        with:
          name: app-win-x64
          path: ${{ github.workspace }}/artifacts/app-win-x64.zip

  build-linux:
    runs-on: ubuntu-latest
    env:
      Configuration: Release

    steps:
      - name: "Checkout repo with full history"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "Setup .NET"
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: "Restore"
        run: dotnet restore

      - name: "Build solution"
        run: dotnet build --no-restore -c ${{ env.Configuration }}

      - name: "Run tests"
        run: dotnet test RcloneFileWatcherCore.Tests/RcloneFileWatcherCore.Tests.csproj --no-build -c ${{ env.Configuration }}

      - name: "Publish Linux app"
        run: dotnet publish RcloneFileWatcherCore/RcloneFileWatcherCore.csproj -c Release -r linux-x64 --self-contained false

      - name: "Prepare Linux artifacts"
        run: |
          mkdir -p "${{ github.workspace }}/artifacts/linux-x64"
          cp "${{ github.workspace }}/RcloneFileWatcherCore/bin/Release/net8.0/linux-x64/publish/RcloneFileWatcherCore" "${{ github.workspace }}/artifacts/linux-x64/" || true
          if [ -f "${{ github.workspace }}/RcloneFileWatcherCore/bin/Release/net8.0/linux-x64/publish/version.json" ]; then
            cp "${{ github.workspace }}/RcloneFileWatcherCore/bin/Release/net8.0/linux-x64/publish/version.json" "${{ github.workspace }}/artifacts/linux-x64/"
          fi
          chmod +x "${{ github.workspace }}/artifacts/linux-x64/RcloneFileWatcherCore" || true
          cd "${{ github.workspace }}/artifacts/linux-x64" && zip -r "../app-linux-x64.zip" . || true

      - name: "Upload Linux artifacts"
        uses: actions/upload-artifact@v4
        with:
          name: app-linux-x64
          path: ${{ github.workspace }}/artifacts/app-linux-x64.zip

  create_release:
    needs: [build-windows, build-linux]
    runs-on: ubuntu-latest
    steps:
      - name: "Checkout repo with full history"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "Download all artifacts"
        uses: actions/download-artifact@v4
        with:
          path: ${{ github.workspace }}/artifacts

      - name: "Debug: list downloaded artifacts"
        run: |
          echo "PWD: $(pwd)"
          echo "Listing artifacts directory:"
          ls -la "${{ github.workspace }}/artifacts" || true
          echo "Listing any nested files (maxdepth 3):"
          find "${{ github.workspace }}/artifacts" -maxdepth 3 -type f -print -exec ls -la {} \; || true

      - name: "Flatten artifact files into artifacts/ root (if needed)"
        run: |
          set -e
          ART_DIR="${{ github.workspace }}/artifacts"

          for dir in "$ART_DIR"/*; do
            if [ -d "$dir" ]; then
              echo "Processing folder: $dir"
              mv "$dir"/* "$ART_DIR"/ 2>/dev/null || true
            fi
          done

          echo "After flatten:"
          ls -la "$ART_DIR" || true

      - name: "Generate changelog"
        id: changelog
        run: |
          git fetch --tags
          latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$latest_tag" ]; then
            echo "No previous tag found, including full history" >&2
            log=$(git log --pretty=format:"- %s [%h] by %an" | grep -E '^- (feat|fix|BREAKING CHANGE):' || true)
          else
            echo "Generating changelog since $latest_tag" >&2
            log=$(git log "$latest_tag"..HEAD --pretty=format:"- %s [%h] by %an" | grep -E '^- (feat|fix|BREAKING CHANGE):' || true)
          fi

          if [ -z "$log" ]; then
            log="(no changelog entries found)"
          fi

          {
            echo "changelog<<EOF"
            echo "$log"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: "Determine release tag"
        id: set_tag
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            if [ -n "${{ github.event.inputs.tag }}" ]; then
              tag="${{ github.event.inputs.tag }}"
            else
              tag="v${{ needs.build-windows.outputs.version }}"
            fi
          else
            tag="${{ github.ref_name }}"
            if [ -z "$tag" ]; then
              tag="v${{ needs.build-windows.outputs.version }}"
            fi
          fi

          echo "Determined release tag: $tag" >&2
          echo "release_tag=$tag" >> $GITHUB_OUTPUT

      - name: "Generate SHA256 checksums and checksum outputs"
        id: checksums
        run: |
          set -e
          ART_DIR="${{ github.workspace }}/artifacts"
          cd "$ART_DIR"

          shopt -s nullglob
          zips=( *.zip )
          if [ ${#zips[@]} -eq 0 ]; then
            echo "No zip files found in $ART_DIR"
            echo "checksums<<EOF" >> $GITHUB_OUTPUT
            echo "(no files)" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            exit 0
          fi

          > checksums.txt
          for f in "${zips[@]}"; do
            sha256sum "$f" > "$f.sha256"
            cat "$f.sha256" >> checksums.txt
          done

          {
            echo "checksums<<EOF"
            cat checksums.txt
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: "Show files to be uploaded"
        run: |
          echo "Artifacts directory content:"
          ls -la "${{ github.workspace }}/artifacts" || true

      - name: "Create or update release and upload assets (API)"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          OWNER_REPO="${GITHUB_REPOSITORY}"
          OWNER=${OWNER_REPO%%/*}
          REPO=${OWNER_REPO##*/}
          TAG="${{ steps.set_tag.outputs.release_tag }}"
          RELEASE_NAME="Release ${{ needs.build-windows.outputs.version }}"

          # build body (preserve newlines)
          BODY=$(cat <<EOF
### Changes since last release
${{ steps.changelog.outputs.changelog }}

### Assembly Version
\`${{ needs.build-windows.outputs.version }}\`

### SHA256 checksums
\`\`\`
${{ steps.checksums.outputs.checksums }}
\`\`\`
EOF
)

          echo "Owner: $OWNER, Repo: $REPO, Tag: $TAG"
          echo "Release name: $RELEASE_NAME"
          # Try to GET release by tag
          echo "Checking if release with tag exists..."
          get_resp=$(curl -s -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/vnd.github.v3+json" "https://api.github.com/repos/$OWNER/$REPO/releases/tags/$TAG" || true)

          release_id=$(python - <<PY
import sys, json
try:
    obj = json.load(sys.stdin)
    print(obj.get("id",""))
except:
    print("")
PY
<<<"$get_resp")

          if [ -n "$release_id" ]; then
            echo "Release exists with id=$release_id — updating body..."
            # prepare JSON payload for update
            payload=$(python - <<PY
import os,json
print(json.dumps({
  "name": os.environ["RELEASE_NAME"],
  "body": os.environ["BODY"],
  "draft": False,
  "prerelease": False
}))
PY
RELEASE_NAME="$RELEASE_NAME" BODY="$BODY")
            update_resp=$(curl -s -X PATCH -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/vnd.github.v3+json" "https://api.github.com/repos/$OWNER/$REPO/releases/$release_id" -d "$payload")
            upload_url=$(python - <<PY
import sys,json
obj=json.load(sys.stdin)
print(obj.get("upload_url",""))
PY
<<<"$update_resp")
          else
            echo "Release does not exist — creating..."
            payload=$(python - <<PY
import os,json
print(json.dumps({
  "tag_name": os.environ["TAG"],
  "name": os.environ["RELEASE_NAME"],
  "body": os.environ["BODY"],
  "draft": False,
  "prerelease": False
}))
PY
TAG="$TAG" RELEASE_NAME="$RELEASE_NAME" BODY="$BODY")
            create_resp=$(curl -s -X POST -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/vnd.github.v3+json" "https://api.github.com/repos/$OWNER/$REPO/releases" -d "$payload")
            release_id=$(python - <<PY
import sys,json
obj=json.load(sys.stdin)
print(obj.get("id",""))
PY
<<<"$create_resp")
            upload_url=$(python - <<PY
import sys,json
obj=json.load(sys.stdin)
print(obj.get("upload_url",""))
PY
<<<"$create_resp")
          fi

          if [ -z "$upload_url" ]; then
            echo "Failed to get upload_url for release (release_id=$release_id). Response from API:"
            echo "get_resp:"
            echo "$get_resp"
            exit 1
          fi

          # strip template part {?name,label}
          upload_url_base=${upload_url%\{*}
          echo "Upload base URL: $upload_url_base"

          ART_DIR="${{ github.workspace }}/artifacts"
          cd "$ART_DIR"

          # upload each zip and its .sha256 (delete existing asset with same name first)
          for file in *.zip *.sha256; do
            if [ ! -f "$file" ]; then
              continue
            fi
            fname=$(basename "$file")
            echo "Processing asset: $fname"

            # check existing assets and delete if asset with same name exists
            assets_resp=$(curl -s -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/vnd.github.v3+json" "https://api.github.com/repos/$OWNER/$REPO/releases/$release_id/assets")
            asset_id=$(python - <<PY
import sys, json
arr=json.load(sys.stdin)
for a in arr:
    if a.get("name","")==sys.argv[1]:
        print(a.get("id",""))
        break
PY
"$fname" <<<"$assets_resp")

            if [ -n "$asset_id" ]; then
              echo "Asset with same name exists (id=$asset_id). Deleting it first..."
              curl -s -X DELETE -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/vnd.github.v3+json" "https://api.github.com/repos/$OWNER/$REPO/releases/assets/$asset_id" || true
            fi

            if [[ "$fname" == *.zip ]]; then
              content_type="application/zip"
            else
              content_type="text/plain"
            fi

            echo "Uploading $fname ..."
            # upload asset
            resp=$(curl -s -X POST -H "Authorization: token $GITHUB_TOKEN" -H "Content-Type: $content_type" --data-binary @"$file" "$upload_url_base?name=$fname")
            # basic check if upload succeeded (response contains id)
            uploaded_id=$(python - <<PY
import sys,json
try:
  obj=json.load(sys.stdin)
  print(obj.get("id",""))
except:
  print("")
PY
<<<"$resp")
            if [ -z "$uploaded_id" ]; then
              echo "Upload failed for $fname. Server response:"
              echo "$resp"
              exit 1
            fi
            echo "Uploaded asset id=$uploaded_id"
          done

          echo "Release id=$release_id updated and assets uploaded successfully."
